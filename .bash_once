# vim: set ft=sh:

# echo "loading ~/.bash_once [flags: $-]"

HISTSIZE=50000
HISTTIMEFORMAT='%Y/%m/%d %H:%M:%S '

shopt -s autocd

if [ -z "${USER_PATH_ADDED}" ]; then
echo "[add user path]"
export PATH="\
${HOME}/.cargo/bin:\
${HOME}/.anyenv/bin:\
${HOME}/.local/bin:\
${HOME}/dev/bin:\
/opt/bin:\
/opt/sbt/bin:\
/opt/platform-tools:\
${HOME}/.dotfiles/bin:\
${PATH}" && export USER_PATH_ADDED=true
fi

if [ -z "${ANYENV_EVALUATED}" ]; then
    echo -n "[init anyenv] ..."
    eval "$(anyenv init -)" && export ANYENV_EVALUATED=true
fi

if [ -z "${YARN_PATH_ADDED}" ]; then
export PATH="\
${HOME}/.config/yarn/global/node_modules/.bin:\
${HOME}/.yarn/bin:\
$PATH" && export YARN_PATH_ADDED=true
fi

[ -f ~/.fzf.bash ] && source ~/.fzf.bash

eval "$(direnv hook bash)"

export JAVA_HOME=/opt/java/java-home-symlink
export GOPATH=$HOME/dev

alias a=alias
alias v=vim
alias ls='ls --color=auto -F'
alias ll='ls -l'
alias la='ls -a'
alias wh=which
alias ty=type
alias s=sudo
alias tm=tmux
alias tl=tail
alias tlf='tail -f'

alias p='sudo pacman'
alias yao=yaourt
alias stl=systemctl

alias mt=multitail
alias g=git
alias dk=docker
alias dkc=docker-compose
alias cci=circleci
alias k=kubectl

alias y=yarn
alias r='rails'
alias be='bundle exec'
alias rac='bundle exec rails c'
alias racs='bundle exec rails c --sandbox'
alias ras='bundle exec rails s'
alias rbo='bundle exec rubocop'

# -- functions
alias pbcopy='xsel --clipboard --input'

showPath() {
    echo $PATH | sed 's/:/\n/g'
}

PS1='\u@\h \W\n\$ '

# -- [configure git completion and promppt]
source /usr/share/git/completion/git-completion.bash
__git_complete g __git_main

source /usr/share/git/completion/git-prompt.sh

GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_SHOWUPSTREAM=auto
GIT_PS1_SHOWUNTRACKEDFILES=1
GIT_PS1_SHOWSTASHSTATE=1

PS1='\u@\h \w$(__git_ps1)\n\$ '

gcd() {
  local branches branch
  branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)") &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

http() {
    cat ~/.dotfiles/http-status.txt | fzf-tmux
}

fzf-ghq-widget () {
    local selected=`ghq list --full-path | fzf` || return $?
    READLINE_LINE="${READLINE_LINE:0:$READLINE_POINT}$selected${READLINE_LINE:$READLINE_POINT}";
    READLINE_POINT=$(( READLINE_POINT + ${#selected} ));
}
bind -x '"\C-g": "fzf-ghq-widget"'

load-gcp-sdk () {
    echo "[$date] google-cloud-sdk loaded"
    # The next line enables shell command completion for gcloud.
    if [ -f '/opt/google-cloud-sdk/completion.bash.inc' ]; then
        source '/opt/google-cloud-sdk/completion.bash.inc'
        source '/opt/google-cloud-sdk/path.bash.inc'
        alias gcl-interactive="gcloud alpha interactive"
    fi
}
if [ -z "${GC_SDK_LOADED}" ]; then
    load-gcp-sdk
    export GC_SDK_LOADED=true
fi

function kubectl-set-ns() {
  kubectl config set-context $(kubectl config current-context) --namespace=$1
}
function kubectl-get-ns() {
  kubectl config view | grep namespace
}

mkcd () {
    mkdir -p $1 && cd $1
}

function ignore-bidning-pry() {
    echo "Lint/Debugger:" >> ./.rubocop_todo.yml
    echo "  Enabled: false" >> ./.rubocop_todo.yml
}

function rec() {
  local filename="$HOME/screencast/$(date '+%Y-%m-%d_%H%M%S').gif"
  byzanz-record $filename --cursor --x=1366 -d 10 && google-chrome-stable $filename
}

source $HOME/localrc.d/*
